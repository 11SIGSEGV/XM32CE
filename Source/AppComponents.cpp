/*
  ==============================================================================

    AppComponents.cpp
    Created: 28 May 2025 3:53:04pm
    Author:  anony

  ==============================================================================
*/

#include "AppComponents.h"

#include <memory>

#include "OSCMan.h"


OSCActionConstructor::MainComp::MainComp(const CueOSCAction& editThisAction) {
    setSize(1000, 800);
    // Template Categories never change, so let's set it now
    int i = 0;
    for (auto &[tpltCategory, tpltGroup]: TEMPLATE_CATEGORY_MAP) {
        i++;
        tpltCategoryDd.addItem(tpltGroup.name, i);
        dDitemIDtoCategory[i] = tpltCategory;
    }

    uiInit();
    findEditThisActionsTemplate(editThisAction);

    // If we found a suitable template
    if (currentTemplateCopy != nullptr && currentTemplateCopy->CATEGORY != NUL) {
        // We need to update the dropdown
        auto tpltCategoryDdID = findKeyByValue(dDitemIDtoCategory, currentTemplateCopy->CATEGORY);

        // Check the category is available in the dropdown
        if (!tpltCategoryDdID.has_value()) {
            return;
        }


        indexOfLastTemplateSelected = -1;
        tpltCategoryDd.setSelectedId(tpltCategoryDdID.value(), dontSendNotification);
        currentCategory = currentTemplateCopy->CATEGORY;
        changeTpltDdBasedOnTpltCategory(currentTemplateCopy->CATEGORY, currentTemplateCopy->ID);
        indexOfLastTemplateSelected = tpltDd.getSelectedItemIndex();
        uponNewTemplateSelected();

        if (editThisAction.oat == OAT_FADE) {
            // Second input changeStore not reflected.
            lastValidFadeTime = std::max(0.f, editThisAction.fadeTime);
            fadeTimeInput.setText(String(lastValidFadeTime), dontSendNotification);
            enableFadeCommandBtn.setToggleState(true, sendNotification);
            inputValues.first.changeStore(editThisAction.startValue);
            inputValues.second.changeStore(editThisAction.endValue);
        } else {
            inputValues.first.changeStore(editThisAction.argument);
        }
        uponValueStorerExternallyChanged(true, (editThisAction.oat == OAT_FADE));
        pathFromEditThisAction = editThisAction.oscAddress.toString();
        reconstructImage(); // To update pathFromEditThisAction.
    }
}


void OSCActionConstructor::MainComp::uiInit() {
    tpltCategoryDd.setColour(ComboBox::ColourIds::backgroundColourId, UICfg::TRANSPARENT);
    tpltCategoryDd.setColour(ComboBox::ColourIds::textColourId, UICfg::TEXT_ACCENTED_COLOUR);
    addAndMakeVisible(tpltCategoryDd);
    tpltCategoryDd.addListener(this);

    tpltDd.setColour(ComboBox::ColourIds::backgroundColourId, UICfg::TRANSPARENT);
    tpltDd.setColour(ComboBox::ColourIds::textColourId, UICfg::TEXT_ACCENTED_COLOUR);
    addAndMakeVisible(tpltDd);
    tpltDd.addListener(this);

    addAndMakeVisible(enableFadeCommandBtn);
    enableFadeCommandBtn.addListener(this);

    addAndMakeVisible(firstInputMethodDd);
    addChildComponent(secondInputMethodDd);
    firstInputMethodDd.addListener(this);
    secondInputMethodDd.addListener(this);

    okBtn.setButtonText("Ok");
    okBtn.setColour(TextButton::ColourIds::buttonColourId, UICfg::POSITIVE_BUTTON_COLOUR);
    okBtn.setColour(TextButton::ColourIds::buttonOnColourId, UICfg::POSITIVE_DOWN_BUTTON_COLOUR);
    okBtn.setColour(TextButton::ColourIds::textColourOnId, UICfg::TEXT_COLOUR);
    cancelBtn.setButtonText("Cancel");
    cancelBtn.setColour(TextButton::ColourIds::buttonColourId, UICfg::NEGATIVE_BUTTON_COLOUR);
    cancelBtn.setColour(TextButton::ColourIds::buttonOnColourId, UICfg::NEGATIVE_DOWN_BUTTON_COLOUR);
    cancelBtn.setColour(TextButton::ColourIds::textColourOnId, UICfg::TEXT_COLOUR);
    addAndMakeVisible(okBtn);
    addAndMakeVisible(cancelBtn);
    okBtn.addListener(this);
    cancelBtn.addListener(this);

    addChildComponent(fadeTimeInput);
    fadeTimeInput.setColour(Label::ColourIds::backgroundColourId, UICfg::TRANSPARENT);
    fadeTimeInput.setColour(Label::ColourIds::outlineColourId, UICfg::TEXT_COLOUR);
    fadeTimeInput.setColour(Label::ColourIds::outlineWhenEditingColourId, UICfg::TEXT_ACCENTED_COLOUR);
    fadeTimeInput.setEditable(true);
    fadeTimeInput.addListener(this);

    firstInputMethodDd.setColour(DropdownWrapper::ColourIds::backgroundColourId, UICfg::TRANSPARENT);
    secondInputMethodDd.setColour(DropdownWrapper::ColourIds::backgroundColourId, UICfg::TRANSPARENT);
    firstInputMethodDd.setColour(DropdownWrapper::ColourIds::outlineColourId, UICfg::TEXT_COLOUR);
    secondInputMethodDd.setColour(DropdownWrapper::ColourIds::outlineColourId, UICfg::TEXT_COLOUR);
    firstInputMethodDd.setColour(DropdownWrapper::ColourIds::focusedOutlineColourId, UICfg::TEXT_COLOUR);
    secondInputMethodDd.setColour(DropdownWrapper::ColourIds::focusedOutlineColourId, UICfg::TEXT_COLOUR);
    firstInputMethodDd.setColour(DropdownWrapper::ColourIds::textColourId, UICfg::TEXT_COLOUR);
    secondInputMethodDd.setColour(DropdownWrapper::ColourIds::textColourId, UICfg::TEXT_COLOUR);
}



void OSCActionConstructor::MainComp::findEditThisActionsTemplate(const CueOSCAction& editThisAction) {
    if (editThisAction.oat == EXIT_THREAD || editThisAction.argumentTemplateID.empty()) {
        return; // Can't find
    }
    // Try find template from ID.
    auto it = ID_TO_TEMPLATE_MAP.find(editThisAction.argumentTemplateID);
    // We couldn't find it...
    if (it == ID_TO_TEMPLATE_MAP.end()) {
        return;
    }

    // Verify details
    // If template is COMMAND
    if (editThisAction.oat == OAT_COMMAND) {
        if (auto *optVal = std::get_if<OptionParam>(&editThisAction.oatCommandOSCArgumentTemplate)) {
            // Not supported!
            return;
        } else if (auto *enumParam = std::get_if<EnumParam>(&editThisAction.oatCommandOSCArgumentTemplate)) {
            if (enumParam->isSimilar(it->second.ENUMPARAM)) {
                // We've found it!
                currentTemplateCopy = std::make_unique<XM32Template>(it->second);
            }
            return;
        } else if (auto *nonIter = std::get_if<NonIter>(&editThisAction.oatCommandOSCArgumentTemplate)) {
            if (nonIter->isSimilar(it->second.NONITER)) {
                // Found it!
                currentTemplateCopy = std::make_unique<XM32Template>(it->second);
            }
            return;
        }
        // Otherwise, we expect a FADE_COMMAND
    } else if (editThisAction.oscArgumentTemplate.isSimilar(it->second.NONITER)) {
        // We've found the action!
        currentTemplateCopy = std::make_unique<XM32Template>(it->second);
        return;
    }
}

void OSCActionConstructor::MainComp::resized() {
    auto bounds = getLocalBounds();
    auto heightTenths = bounds.getHeight() * 0.1;
    fontSize = heightTenths * 0.3;
    auto widthTenths = bounds.getWidth() * 0.1;

    // First, set the 'area' boxes.
    tpltSelectionBox = bounds.removeFromTop(heightTenths);
    descBox = bounds.removeFromTop(heightTenths);
    fadeCmdBox = tpltSelectionBox.removeFromRight(widthTenths * 2);
    tpltSelectionBox.removeFromRight(widthTenths * 0.2); // Padding
    pathBox = bounds.removeFromTop(heightTenths * 1.5);
    buttonsBox = bounds.removeFromBottom(heightTenths * 0.7);
    argBox = bounds;

    // We don't want to screw up the padding. We expect a 5:4 width:height ratio, so if the width is below this
    // ratio, then we'll need to use the height for padding instead.
    float padding;
    if (bounds.getWidth() / 5 > bounds.getHeight() / 4)
        padding = bounds.getHeight() * UICfg::STD_PADDING;
    else
        padding = bounds.getWidth() * UICfg::STD_PADDING;


    // Description box padding - the path box below already pads the bottom for descBox
    descBox.removeFromLeft(padding);
    descBox.removeFromTop(padding);
    descBox.removeFromRight(padding);


    // Let's split up the template selection area.
    auto selBoxCp = tpltSelectionBox;
    selBoxCp.removeFromLeft(padding); // Left Padding for text

    // Top is for Template Cat., Bottom is for actual Template
    auto selBoxTop = selBoxCp.removeFromTop(selBoxCp.getHeight() * 0.5);
    auto selBoxBottom = selBoxCp;

    // Title box refers to the text "Template Category" or smth to the left of the dropdown
    tpltCategoryTitleBox = selBoxTop.removeFromLeft(selBoxTop.getWidth() * 0.4);
    selBoxTop.removeFromLeft(selBoxTop.getWidth() * 0.1); // Padding
    tpltCategoryDropBox = selBoxTop;
    tpltCategoryDd.setBounds(tpltCategoryDropBox);

    tpltSelectionTitleBox = selBoxBottom.removeFromLeft(selBoxBottom.getWidth() * 0.4);
    selBoxBottom.removeFromLeft(selBoxBottom.getWidth() * 0.1); // Padding
    tpltSelectionDropBox = selBoxBottom;
    tpltDd.setBounds(tpltSelectionDropBox);


    // Let's split up the fade command area.
    auto fdBoxCp = fadeCmdBox;
    fdBoxCp = fdBoxCp.reduced(padding / 2); // Padding
    fadeCmdTextBox = fdBoxCp.removeFromTop(fdBoxCp.getHeight() * 0.5);
    auto _minLen = std::min(fdBoxCp.getWidth(), fdBoxCp.getHeight());
    fadeCmdButtonBox = Rectangle(fdBoxCp.getX(), fdBoxCp.getY(), _minLen, _minLen); // Ensure square.
    enableFadeCommandBtn.setBounds(fadeCmdButtonBox);

    // Ok, time for the path box.
    auto pthBoxCp = pathBox;
    pthBoxCp = pthBoxCp.reduced(padding); // Padding
    pathTitleBox = pthBoxCp.removeFromTop(pthBoxCp.getHeight() * 0.3);
    pathInputBox = pthBoxCp;

    // And now for the argument box.
    auto argsBoxCp = argBox;
    argsBoxCp.removeFromTop(padding);

    auto argTitleBox = argsBoxCp.removeFromTop(argsBoxCp.getHeight() * 0.08);
    argTitleBoxLeft = argTitleBox.removeFromLeft(argTitleBox.getWidth() * 0.5);
    argTitleBoxLeft.removeFromLeft(padding); // Padding
    // First Input Method Box
    auto fimBox = argTitleBoxLeft.removeFromRight(argTitleBoxLeft.getWidth() * 0.2);
    argTitleBoxRight = argTitleBox;
    argTitleBoxRight.removeFromRight(padding);
    argTitleBoxRight.removeFromLeft(padding);
    // Second Input Method Box
    auto simBox = argTitleBoxRight.removeFromRight(argTitleBoxRight.getWidth() * 0.2);
    // Next to both title boxes, we need the dropdown bounds
    firstInputMethodDd.setBounds(fimBox);
    secondInputMethodDd.setBounds(simBox);

    argInputAreaLeft = argsBoxCp.removeFromLeft(argsBoxCp.getWidth() * 0.5);
    argInputAreaLeft.reduce(padding, padding);
    argInputAreaRight = argsBoxCp;
    argInputAreaRight.reduce(padding, padding);

    // Buttons Box
    auto btnBoxCp = buttonsBox;
    okBtn.setBounds(btnBoxCp.removeFromRight(widthTenths));
    btnBoxCp.removeFromRight(widthTenths * 0.2); // Padding
    cancelBtn.setBounds(btnBoxCp.removeFromRight(widthTenths));

    btnBoxCp.removeFromLeft(padding);
    fadeTimeInputTitleBox = btnBoxCp.removeFromLeft(btnBoxCp.getWidth() * 0.3);
    fadeTimeInput.setBounds(btnBoxCp.removeFromLeft(btnBoxCp.getWidth() * 0.2));
    fadeTimeInput.setFont(monospacePlain.withHeight(fontSize));

    reconstructImage();

    if (currentTemplateCopy != nullptr) {
        resizeArgs();
    }
}

void OSCActionConstructor::MainComp::resizeArgs(bool updateFirst, bool updateSecond) {
    if (!(updateFirst || updateSecond)) {
        return; // Nothing to do.
    }
    // Dear Never-Indenters, please skip the remainder of this function for your own sanity.

    // Let's handle the first arg.
    // Remember to always check if we've effed up and set a unique_ptr to nullptr.
    if (updateFirst) {
        int leftWidth = argInputAreaLeft.getWidth();
        int leftHeight = argInputAreaLeft.getHeight();
        switch (firstInputMethod) {
            case FADER: {
                if (faderInputs.first == nullptr) {
                    jassertfalse; // hiyyya debugging time
                    break;
                }
                // We want an approximately 3:8 width to height ratio.
                int height;
                int width;
                if (leftWidth / 3 < leftHeight / 8) {
                    // We don't have enough width, so we'll determine the height off the width.
                    width = leftWidth;
                    height = std::ceil(leftWidth / 3 * 8);
                } else {
                    width = std::floor(leftHeight / 8 * 3);
                    height = leftHeight;
                }
                faderInputs.first->setBounds(argInputAreaLeft.getX(), argInputAreaLeft.getY(), width, height);
                break;
            }
            case ENCODER: {
                if (encoderInputs.first == nullptr) {
                    jassertfalse; // YOU'RE........ well aren't I glad we have universal free healthcare in Australia
                    // CAUSE I'M GONNA GET A EFFING HERNIA AHHAHAHDSAHDAYDYO&*y*bstoduDY7HUDH9UP38EU12HUHN8Nsyd*76YsDYsud)&*)sd68
                    break;
                }
                // We just need to keep it square
                int widthAndHeight = std::min(leftWidth, leftHeight);
                encoderInputs.first->setBounds(argInputAreaLeft.getX(), argInputAreaLeft.getY(), widthAndHeight,
                                               widthAndHeight);
                break;
            }
            case DROPDOWN: {
                if (ddInputs.first == nullptr) {
                    jassertfalse; // *sigh* if I commit suicide, I want you to know that my body's probably somewhere in a
                    // national park in Katoomba or Wentworth Falls.
                    // Can you really blame me though? It's a pretty place to get away from this crapshow... permanently.
                    break;
                }
                // We know the fontsize, we'll add a bit to that and set the width to the entire width of the box.
                ddInputs.first->setBounds(argInputAreaLeft.getX(), argInputAreaLeft.getY(), leftWidth, fontSize * 1.2f);
                break;
            }
            case TEXTBOX: {
                if (textInputs.first == nullptr) {
                    jassertfalse; // I never thought I'd go through something more painful than that CIA black site
                    break;
                }
                // Simply give it the entire bounds.
                textInputs.first->setBounds(argInputAreaLeft);

                // Set new font size while we're at it
                textInputs.first->setFont(monospacePlain.withHeight(fontSize));
                break;
            }
            case BUTTON_ARRAY: {
                if (btnArrInputs.first == nullptr) {
                    /* Did you know there's a fungus called Ophiocordyceps unilateralis, commonly known as the zombie-ant
                     * fungus?
                     * It infects ants, takes over their central nervous system, and compels them to climb to a high point
                     * (like the underside of a leaf or a branch). Once the ant is in position, the fungus kills it, and a
                     * stalk erupts from the ant's head, releasing spores to infect more ants below. The ant's body remains
                     * clamped to its perch, essentially serving as a fungal launchpad.
                     *
                     * Anyway, how's your day? */
                    jassertfalse;
                    break;
                }
                jassertfalse; // Implement
                // TODO: fix.
                break;
            }
            case NONE:
                jassertfalse;
                // AHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
                break;
        }
    }

    if (updateSecond) {
        int rightWidth = argInputAreaRight.getWidth();
        int rightHeight = argInputAreaRight.getHeight();
        switch (secondInputMethod) {
            case FADER: {
                if (faderInputs.second == nullptr) {
                    // According to Buzzfeed, refrigerators are magnetic because kids used to die inside them. Before 1956,
                    // refrigerators could only be opened from the outside.
                    // I wish it was 1955.
                    jassertfalse;
                    break;
                }
                // We want an approximately 3:8 width to height ratio.
                int height;
                int width;
                if (rightWidth / 3 < rightHeight / 8) {
                    // We don't have enough width, so we'll determine the height off the width.
                    width = rightWidth;
                    height = std::ceil(rightWidth / 3 * 8);
                } else {
                    width = std::floor(rightHeight / 8 * 3);
                    height = rightHeight;
                }
                faderInputs.second->setBounds(argInputAreaRight.getX(), argInputAreaRight.getY(), width, height);
                break;
            }
            case ENCODER: {
                if (encoderInputs.second == nullptr) {
                    jassertfalse; // I've kind of run out
                    break;
                }
                // We just need to keep it square
                int widthAndHeight = std::min(rightWidth, rightHeight);
                encoderInputs.second->setBounds(argInputAreaRight.getX(), argInputAreaRight.getY(), widthAndHeight, widthAndHeight);
                break;
            }
            case DROPDOWN: {
                if (ddInputs.second == nullptr) {
                    jassertfalse; // *sigh* if I commit suicide, I want you to know that my body's probably somewhere in a
                    // national park in Katoomba or Wentworth Falls.
                    // Can you really blame me though? It's a pretty place to get away from this crapshow... permanently.
                    break;
                }
                // We know the fontsize, we'll add a bit to that and set the width to the entire width of the box.
                ddInputs.second->setBounds(argInputAreaRight.getX(), argInputAreaRight.getY(), rightWidth, fontSize * 1.2f);
                break;
            }
            case TEXTBOX: {
                if (textInputs.second == nullptr) {
                    jassertfalse; // I never thought I'd go through something more painful than that CIA black site
                    break;
                }
                // Simply give it the entire bounds.
                textInputs.second->setBounds(argInputAreaRight);

                // Set new font size while we're at it
                textInputs.second->setFont(monospacePlain.withHeight(fontSize));
                break;
            }
            case BUTTON_ARRAY: {
                if (btnArrInputs.second == nullptr) {
                    /* Did you know there's a fungus called Ophiocordyceps unilateralis, commonly known as the zombie-ant
                     * fungus?
                     * It infects ants, takes over their central nervous system, and compels them to climb to a high point
                     * (like the underside of a leaf or a branch). Once the ant is in position, the fungus kills it, and a
                     * stalk erupts from the ant's head, releasing spores to infect more ants below. The ant's body remains
                     * clamped to its perch, essentially serving as a fungal launchpad.
                     *
                     * Anyway, how's your day? */
                    jassertfalse;
                    break;
                }
                jassertfalse; // Implement
                // TODO: fix.
                break;
            }
            case NONE:
                break;
        }
    }
}


void OSCActionConstructor::MainComp::paint(Graphics &g) {
    g.drawImage(backgroundImage, getLocalBounds().toFloat());
    // Draw this here. We don't include this in the image as we will call repaint() if we turn on or off a fade command
    g.setColour(UICfg::TEXT_COLOUR);
    g.setFont(font);
    g.setFont(fontSize);
    if (enableFadeCommandBtn.getToggleState()) {
        g.drawText("Start Value", argTitleBoxLeft, Justification::centredLeft);
        g.drawText("End Value", argTitleBoxRight, Justification::centredLeft);
    } else
        g.drawText("Value", argTitleBoxLeft, Justification::centredLeft);

}


void OSCActionConstructor::MainComp::reconstructImage() {
    backgroundImage = Image(Image::ARGB, getLocalBounds().getWidth(), getLocalBounds().getHeight(), true);
    Graphics g(backgroundImage);

    g.setFont(font);
    g.setFont(fontSize);
    g.setColour(UICfg::TEXT_COLOUR);

    g.drawText("Select a template category", tpltCategoryTitleBox, Justification::centredLeft);
    g.drawText("Select a template", tpltSelectionTitleBox, Justification::centredLeft);


    // Must pre-initalise bool and String in case no template selected yet
    bool fadeEnabled; // To clarify, fade enabled refers to if the template supports fading, not if the user has enabled it.
    String tpltDescription;
    if (currentTemplateCopy == nullptr) {
        fadeEnabled = false;
    } else {
        fadeEnabled = currentTemplateCopy->FADE_ENABLED;
        if (currentTemplateCopy->_META_UsesNonIter)
            tpltDescription = currentTemplateCopy->NONITER.description;
        else
            tpltDescription = currentTemplateCopy->ENUMPARAM.description;
    }

    // Let's figure out the fade
    if (fadeEnabled) {
        g.setColour(UICfg::BG_SECONDARY_COLOUR);
        g.fillRect(fadeCmdBox);
        g.setColour(UICfg::TEXT_COLOUR);
        g.setFont(font);
        g.setFont(fontSize);
        g.drawText("Fade Time (s)", fadeTimeInputTitleBox, Justification::centredLeft);
    }
    g.setFont(fontSize * 0.7);
    g.drawFittedText(fadeEnabled ? "Enable fade command?" : "Fading Not Available",
                     fadeCmdTextBox, Justification::centredLeft, 2);

    // Now for description
    g.setFont(descFont);
    g.setFont(fontSize);
    g.drawFittedText(tpltDescription, descBox, Justification::topLeft,
                     static_cast<int>(std::floor(descBox.getHeight() / fontSize)));

    // We also have to draw lines for each "section"
    // One for Template Selection & Description
    Rectangle<int> seperator1 {0, descBox.getBottom(), getWidth(), static_cast<int>(std::ceil(getHeight() * 0.001))};
    g.drawRect(seperator1);
    Rectangle<int> seperator2 {0, pathBox.getBottom(), getWidth(), static_cast<int>(std::ceil(getHeight() * 0.001))};
    g.drawRect(seperator2);

    // Let's handle the path/inputs!
    g.setFont(font);
    g.setFont(fontSize);
    g.drawText("Path", pathTitleBox, Justification::centredLeft);

    // We need to reset the inputs upon a reconstruction.
    // HOWEVER, everything else stays.
    pathLabelInputs.clear();

    // No template is selected the first time the component is started, so check for nullptr.
    if (currentTemplateCopy == nullptr) {
        return;
    }

    // Handle in-path arguments
    Font fCopy = monospace;
    fCopy.setHeight(fontSize);
    fCopy.setStyleFlags(Font::plain);

    g.setFont(fCopy);
    Rectangle<int> pathBoxRemaining = pathInputBox;

    // Number of items in pathLabelInputValues (i.e., already generated values and not
    // cleared). If this is above 0, it is basically guaranteed the reconstructImage was called as a result of a resize
    // so the previous text should be restored.
    size_t existingLabelValuesSize = pathLabelInputValues.size();
    int numArgs{0};

    for (const auto &argTemplate: currentTemplateCopy->PATH) {
        if (pathBoxRemaining.getWidth() == 0) {
            jassertfalse; // We've literally run out of screen area... HOW LONG IS THE PATH?
            // OR WORSE, WHAT'S THE RESOLUTION OF YOUR WINDOW?
        }
        if (auto *string = std::get_if<std::string>(&argTemplate)) {
            // Draw the string
            String str{string->c_str()};
            g.drawText(str, pathBoxRemaining, Justification::centredLeft);
            pathBoxRemaining.removeFromLeft(GlyphArrangement::getStringWidthInt(fCopy, str));
        } else if (auto *nonIter = std::get_if<NonIter>(&argTemplate)) {
            // Create a new input label for the in-path argument
            bool autoAddToOtherVectors = true;
            numArgs++;
            String lblTxt;
            if (numArgs <= existingLabelValuesSize) {
                // Ok, we have an existing value to pull.
                lblTxt = pathLabelInputValues.at(numArgs - 1);
                autoAddToOtherVectors = false; // We already have a corresponding value for this label,
                // and hence we'd have a corresponding template and formatted value, and hence we don't need a new one.
                // Adding a new one would result in the 4 vectors being different sizes.
            }
            // See if previously registered text is available
            addInPathArgLabel(*nonIter, pathBoxRemaining, fCopy, lblTxt, autoAddToOtherVectors);
        }
    }
    // Now if we have a pathFromEditThisAction, note that in brackets.
    if (pathFromEditThisAction.isNotEmpty()) {
        g.setFont(g.getCurrentFont().getHeight() * 0.7f);
        g.drawText(" (also using \"" + pathFromEditThisAction + "\")", pathBoxRemaining, Justification::centredLeft);
    }
}


Rectangle<int> OSCActionConstructor::MainComp::findProperLabelBounds(const NonIter &argTemplate,
                                                                     Rectangle<int> &remainingBox,
                                                                     const Font &fontInUse) {
    int boxWidth = 0;
    float singleCharWidth = GlyphArrangement::getStringWidth(fontInUse, "W");
    switch (argTemplate._meta_PARAMTYPE) {
        case STRING:
            // Remember, intMax also represents the maximum string length.
            boxWidth = static_cast<int>(std::ceil(singleCharWidth * (argTemplate.intMax + 1)));
            break;
        case INT:
            // We need to find the maximum length because of the negative sign. For example, a min val of -80 and max
            // val of 20 would mean the maximum length accounted for is 2 characters, but that's not right. It should be
            // 3 chars (because "-80" is 3 chars).
            // The extra 1 character is because the text box has margin.
            boxWidth = static_cast<int>(std::ceil(
                    (std::max(
                         std::to_string(argTemplate.intMax).length(),
                         std::to_string(argTemplate.intMin).length()
                     ) + 1) * singleCharWidth)
            );
            break;
        default:
            jassertfalse; // Unallowed ParamType for an in-path label (text input field)
            return {};
    }
    if (remainingBox.getWidth() < boxWidth) {
        jassertfalse; // We've run out of space! Help!
    }
    return remainingBox.removeFromLeft(boxWidth);
}


void OSCActionConstructor::MainComp::addInPathArgLabel(const NonIter &argTemplate, Rectangle<int> &remainingBox,
                                                       const Font &fontInUse, const String &text,
                                                       bool automaticallyAddToOtherVectors) {
    auto lblBounds = findProperLabelBounds(argTemplate, remainingBox, fontInUse);
    auto lbl = std::make_unique<Label>(argTemplate.name);

    lbl->setColour(Label::ColourIds::textColourId, UICfg::TEXT_ACCENTED_COLOUR);
    lbl->setColour(Label::ColourIds::backgroundWhenEditingColourId, UICfg::BG_SECONDARY_COLOUR);
    lbl->setColour(Label::ColourIds::outlineColourId, UICfg::TEXT_ACCENTED_COLOUR);
    lbl->setFont(fontInUse);
    lbl->setEditable(true);
    lbl->setHelpText(argTemplate.verboseName);
    lbl->setBounds(lblBounds);
    lbl->addListener(this);

    if (text.isEmpty()) {
        addAndMakeVisible(*lbl);
    }

    if (automaticallyAddToOtherVectors) {
        pathLabelInputTemplates.push_back(argTemplate);
        pathLabelInputValues.push_back(text);
        pathLabelFormattedValues.emplace_back();
    }
    pathLabelInputs.push_back(std::move(lbl));


    // If the string is not empty, we have to get lbl again... yayyyyyyyyyyyyyyyyy
    // Remember, lbl is now invalid because we've just moved it into the pathLabelInputs vector.
    if (text.isNotEmpty()) {
        auto lblFromVec = pathLabelInputs.back().get();
        // Manually set text to trigger listener callback
        lblFromVec->setText(text, sendNotification);
        addAndMakeVisible(*lblFromVec);
    }
}

void OSCActionConstructor::MainComp::comboBoxChanged(ComboBox *comboBoxThatHasChanged) {
    if (comboBoxThatHasChanged == &tpltCategoryDd) {
        indexOfLastTemplateSelected = -1;
        currentCategory = dDitemIDtoCategory.at(tpltCategoryDd.getSelectedId());
        // Update the other dropdown's elements to match the options available for this category
        changeTpltDdBasedOnTpltCategory(currentCategory);
        return;
    }
    // This means our template has changed... i.e., we need to change EVERYTHING.
    if (comboBoxThatHasChanged == &tpltDd) {
        // Using the current category, we'll find the appropriate template according to the ID of the
        // tpltDd dropdown, whose ID will be equivalent to the index of the appropriate XM32Template in the
        // XM32TemplateGroup's vector.

        // No change... same template
        if (tpltDd.getSelectedItemIndex() == indexOfLastTemplateSelected)
            return;


        indexOfLastTemplateSelected = tpltDd.getSelectedItemIndex();
        const XM32TemplateGroup &tpltGroup = TEMPLATE_CATEGORY_MAP.at(currentCategory);
        currentTemplateCopy = std::make_unique<XM32Template>(
            tpltGroup.templates.at(indexOfLastTemplateSelected)
        );
        uponNewTemplateSelected();
        return;
    }

    if (currentParamType == _BLANK) {
        jassertfalse; // Cannot select new input method for blank ParamType
        return;
    }

    if (comboBoxThatHasChanged == &firstInputMethodDd) {
        clearCurrentInputMethod(true, false);
        firstInputMethod = ALLOWED_INPUT_METHODS_FOR_TYPE.at(currentParamType).at(firstInputMethodDd.getSelectedItemIndex());
        uponNewInputMethodSelected(true, false);
    } else if (comboBoxThatHasChanged == &secondInputMethodDd) {
        clearCurrentInputMethod(false, true);
        int currentMethodIndex = secondInputMethodDd.getSelectedItemIndex();
        if (currentMethodIndex == -1 || currentMethodIndex >= ALLOWED_INPUT_METHODS_FOR_TYPE.at(currentParamType).size()) {
            return;
        }
        secondInputMethod = ALLOWED_INPUT_METHODS_FOR_TYPE.at(currentParamType).at(secondInputMethodDd.getSelectedItemIndex());
        uponNewInputMethodSelected(false, true);
    }
}

void OSCActionConstructor::MainComp::uponNewTemplateSelected() {
    if (currentTemplateCopy == nullptr) {
        jassertfalse; // You need the current template to be set for this function to work!
        return;
    }
    currentParamType = currentTemplateCopy->_META_UsesNonIter
                           ? currentTemplateCopy->NONITER._meta_PARAMTYPE
                           : currentTemplateCopy->ENUMPARAM._meta_PARAMTYPE;


    // Set if fade command can be enabled appropriately
    enableFadeCommandBtn.setEnabled(currentTemplateCopy->FADE_ENABLED);
    fadeCommandEnabled = currentTemplateCopy->FADE_ENABLED;
    enableFadeCommandBtn.setToggleState(false, dontSendNotification);
    fadeTimeInput.setVisible(currentTemplateCopy->FADE_ENABLED);
    fadeTimeInput.setEnabled(false);


    // Clear the path label input vectors to hard-reset all path labels
    pathLabelInputs.clear();
    pathLabelInputTemplates.clear();
    pathLabelInputValues.clear();
    pathLabelFormattedValues.clear();
    pathFromEditThisAction = ""; // Reset if user selects a new template. Can no longer use old path.


    // Also clear all inputs child components
    clearInputPair(faderInputs);
    clearInputPair(encoderInputs);
    clearInputPair(ddInputs);
    clearInputPair(textInputs);
    clearInputPair(btnArrInputs);

    inputValues.first.clearStore();
    inputValues.second.clearStore();

    // By this stage, fadeCommandEnabled should still be false.
    // Let's set the allowed input methods dropdown
    if (currentParamType == _BLANK) {
        jassertfalse; // ...I TOLD YOU ALREADY, YOU CAN'T USE THESE!
        return;
    }

    firstInputMethodDd.clear(dontSendNotification);
    secondInputMethodDd.clear(dontSendNotification);

    // Add input method
    auto allowedInpMethods = ALLOWED_INPUT_METHODS_FOR_TYPE.at(currentParamType);
    int i{0};
    for (const auto method: allowedInpMethods) {
        i++; // A reminder that the first item ID cannot be 0.
        firstInputMethodDd.addItem(INPUT_METHOD_NAME.at(method), i);
        secondInputMethodDd.addItem(INPUT_METHOD_NAME.at(method), i);
    }
    // First item is always default.
    firstInputMethodDd.setSelectedItemIndex(0, dontSendNotification);

    firstInputMethod = allowedInpMethods.at(0);
    secondInputMethod = NONE;

    secondInputMethodDd.setVisible(false);
    secondInputMethodDd.setEnabled(false);

    // Let's set the inputValues to the default value, or for EnumParam, just the first value
    // Only need to set the first value as fade is always disabled by default.
    if (currentTemplateCopy->_META_UsesNonIter) {
        switch (currentParamType) {
            case LINF:
            case LOGF:
            case LEVEL_161:
            case LEVEL_1024:
            case _GENERIC_FLOAT:
                inputValues.first.changeStore(currentTemplateCopy->NONITER.defaultFloatValue);
                break;
            case INT:
            case BITSET:
                inputValues.first.changeStore(currentTemplateCopy->NONITER.defaultIntValue);
                break;
            case STRING:
                inputValues.first.changeStore(currentTemplateCopy->NONITER.defaultStringValue);
                break;
            default:
                jassertfalse; // Bad template param type
        }
    } else // Simply set the index we're using for the enum to 0.
        inputValues.first.changeStore(0);

    uponNewInputMethodSelected();

    reconstructImage();
    repaint();
}

void OSCActionConstructor::MainComp::uponNewInputMethodSelected(bool updateFirst, bool updateSecond) {
    if (!(updateFirst || updateSecond)) {
        return; // Nothing to do!
    }
    if (currentTemplateCopy == nullptr) {
        jassertfalse; // please for the last time YOU CAN'T CALL THIS FUNCTION UNTIL YOU GET A TEMPLATE
        return;
    }
    // ReSharper disable once CppDFAConstantConditions
    if (currentParamType == _BLANK) {
        // Ok... we don't want to touch this. There is something wrong.
        jassertfalse; // A valid ParamType is needed to reconstruct the component's inputs
        return;
    }

    // UNI stands for Using NonIter
    const bool UNI = currentTemplateCopy->_META_UsesNonIter;

    if (updateFirst) {
        // ==================================================================================
        // Let's deal with the first input method first.
        // Create new components based on the input method.
        switch (firstInputMethod) {
            case FADER: {
                faderInputs.first.reset(new Fader(currentTemplateCopy->NONITER));
                if (inputValues.first._meta_PARAMTYPE != _BLANK) {
                    // Check if the value is valid
                    switch (inputValues.first._meta_PARAMTYPE) {
                        case _GENERIC_FLOAT: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.first.floatValue)) {
                                faderInputs.first->setValue(inputValues.first.floatValue);
                            }
                            break;
                        }
                        case INT: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.first.intValue)) {
                                faderInputs.first->setValue(inputValues.first.intValue);
                            }
                            break;
                        }
                        default:
                            jassertfalse; // Not supported
                    }
                }
                faderInputs.first->addListener(this);
                addAndMakeVisible(faderInputs.first.get());
                break;
            }
            case ENCODER: {
                if (UNI) {
                    const NonIter& ni = currentTemplateCopy->NONITER;
                    if (currentParamType == INT) {
                        encoderInputs.first.reset(new Encoder(ni._meta_UNIT, -135.0, ni.intMin,
                            135.0, ni.intMax, 0.5, ni.defaultIntValue,
                            formatValueUsingUnit(ni._meta_UNIT, ni.intMin), formatValueUsingUnit(ni._meta_UNIT, ni.intMax),
                            -1, ni._meta_PARAMTYPE, true, false));
                        if (inputValues.first._meta_PARAMTYPE == INT && currentTemplateCopy->NONITER.valueIsValid(inputValues.first.intValue)) {
                            encoderInputs.first->setValue(inputValues.first.intValue);
                        }
                    } else {
                        encoderInputs.first.reset(new Encoder(ni._meta_UNIT, -135.0, ni.floatMin,
                            135.0, ni.floatMax, 0.5, ni.defaultFloatValue,
                            formatValueUsingUnit(ni._meta_UNIT, ni.floatMin), formatValueUsingUnit(ni._meta_UNIT, ni.floatMax),
                            -1, ni._meta_PARAMTYPE, true, false));
                        if (inputValues.first._meta_PARAMTYPE == _GENERIC_FLOAT && currentTemplateCopy->NONITER.valueIsValid(inputValues.first.floatValue)) {
                            encoderInputs.first->setValue(inputValues.first.floatValue);
                        }

                    }
                }
                else {
                    encoderInputs.first.reset(new Encoder(currentTemplateCopy->ENUMPARAM));
                    if (inputValues.first._meta_PARAMTYPE == INT &&
                        currentTemplateCopy->ENUMPARAM.validIndex(inputValues.first.intValue)) {
                        encoderInputs.first->setValue(inputValues.first.intValue);
                    }
                }

                encoderInputs.first->addListener(this);
                addAndMakeVisible(encoderInputs.first.get());
                break;
            }
            case DROPDOWN: {
                ddInputs.first.reset(new DropdownWrapper(currentTemplateCopy->ENUMPARAM));
                if (inputValues.first._meta_PARAMTYPE == INT &&
                    currentTemplateCopy->ENUMPARAM.validIndex(inputValues.first.intValue)) {
                    ddInputs.first->setSelectedItemIndex(inputValues.first.intValue);
                }

                ddInputs.first->addListener(this);
                addAndMakeVisible(ddInputs.first.get());
                break;
            }
            case TEXTBOX: {
                textInputs.first.reset(new TextEditorWrapper(currentTemplateCopy->NONITER));
                if (inputValues.first._meta_PARAMTYPE != _BLANK) {
                    switch (inputValues.first._meta_PARAMTYPE) {
                        case _GENERIC_FLOAT: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.first.floatValue)) {
                                textInputs.first->setText(String(inputValues.first.floatValue));
                            }
                            break;
                        }
                        case INT: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.first.intValue)) {
                                textInputs.first->setText(String(inputValues.first.intValue));
                            }
                            break;
                        }
                        case STRING: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.first.stringValue)) {
                                textInputs.first->setText(String(inputValues.first.stringValue));
                            }
                        }
                        default:
                            jassertfalse; // Not supported
                    }
                }
                textInputs.first->addListener(this);
                addAndMakeVisible(textInputs.first.get());
                break;
            }
            case BUTTON_ARRAY:
                // TODO: Implement
                break;
            case NONE:
                jassertfalse; // ...none isn't even meant to be used for the first input method. I... I don't get it.
                break;
        }
    }

    // ==================================================================================

    if (updateSecond) {
        // Create new components based on the input method.// Create new components based on the input method.
        switch (secondInputMethod) {
            case FADER: {
                faderInputs.second.reset(new Fader(currentTemplateCopy->NONITER));
                if (inputValues.second._meta_PARAMTYPE != _BLANK) {
                    switch (inputValues.second._meta_PARAMTYPE) {
                        case _GENERIC_FLOAT: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.second.floatValue)) {
                                faderInputs.second->setValue(inputValues.second.floatValue);
                            }
                            break;
                        }
                        case INT: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.second.intValue)) {
                                faderInputs.second->setValue(inputValues.second.intValue);
                            }
                            break;
                        }
                        default:
                            jassertfalse; // Not supported
                    }
                }
                faderInputs.second->addListener(this);
                addAndMakeVisible(faderInputs.second.get());
                break;
            }
            case ENCODER: {
                if (UNI) {
                    const NonIter& ni = currentTemplateCopy->NONITER;
                    if (currentParamType == INT) {
                        encoderInputs.second.reset(new Encoder(ni._meta_UNIT, -135.0, ni.intMin,
                            135.0, ni.intMax, 0.5, ni.defaultIntValue,
                            formatValueUsingUnit(ni._meta_UNIT, ni.intMin), formatValueUsingUnit(ni._meta_UNIT, ni.intMax),
                            -1, ni._meta_PARAMTYPE, true, false));
                        if (inputValues.second._meta_PARAMTYPE == INT && currentTemplateCopy->NONITER.valueIsValid(inputValues.second.intValue)) {
                            encoderInputs.second->setValue(inputValues.second.intValue);
                        }
                    } else {
                        encoderInputs.second.reset(new Encoder(ni._meta_UNIT, -135.0, ni.floatMin,
                            135.0, ni.floatMax, 0.5, ni.defaultFloatValue,
                            formatValueUsingUnit(ni._meta_UNIT, ni.floatMin), formatValueUsingUnit(ni._meta_UNIT, ni.floatMax),
                            -1, ni._meta_PARAMTYPE, true, false));
                        if (inputValues.second._meta_PARAMTYPE == _GENERIC_FLOAT && currentTemplateCopy->NONITER.valueIsValid(inputValues.second.floatValue)) {
                            encoderInputs.second->setValue(inputValues.second.floatValue);
                        }
                    }
                }
                else {
                    encoderInputs.second.reset(new Encoder(currentTemplateCopy->ENUMPARAM));
                    if (inputValues.second._meta_PARAMTYPE == INT &&
                        currentTemplateCopy->ENUMPARAM.validIndex(inputValues.second.intValue)) {
                        encoderInputs.second->setValue(inputValues.second.intValue);
                    }
                }
                encoderInputs.second->addListener(this);
                addAndMakeVisible(encoderInputs.second.get());
                break;
            }
            case DROPDOWN: {
                ddInputs.second.reset(new DropdownWrapper(currentTemplateCopy->ENUMPARAM));
                if (inputValues.second._meta_PARAMTYPE == INT &&
                    currentTemplateCopy->ENUMPARAM.validIndex(inputValues.second.intValue)) {
                    ddInputs.second->setSelectedItemIndex(inputValues.second.intValue);
                }
                ddInputs.second->addListener(this);
                addAndMakeVisible(ddInputs.second.get());
                break;
            }
            case TEXTBOX: {
                textInputs.second.reset(new TextEditorWrapper(currentTemplateCopy->NONITER));
                if (inputValues.second._meta_PARAMTYPE != _BLANK) {
                    switch (inputValues.second._meta_PARAMTYPE) {
                        case _GENERIC_FLOAT: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.second.floatValue)) {
                                textInputs.second->setText(String(inputValues.second.floatValue));
                            }
                            break;
                        }
                        case INT: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.second.intValue)) {
                                textInputs.second->setText(String(inputValues.second.intValue));
                            }
                            break;
                        }
                        case STRING: {
                            if (currentTemplateCopy->NONITER.valueIsValid(inputValues.second.stringValue)) {
                                textInputs.second->setText(String(inputValues.second.stringValue));
                            }
                            break;
                        }
                        default:
                            jassertfalse; // Not supported
                    }
                }
                textInputs.second->addListener(this);
                addAndMakeVisible(textInputs.second.get());
                break;
            }
            case BUTTON_ARRAY:
                // TODO: Implement
                break;
            case NONE:
                break;
        }
    }

    resizeArgs(updateFirst, updateSecond);
}

void OSCActionConstructor::MainComp::uponValueStorerExternallyChanged(bool updateFirst, bool updateSecond) {
    if (updateFirst) {
        switch (firstInputMethod) {
            case FADER: {
                if (faderInputs.first == nullptr) {
                    jassertfalse; // No fader initalised
                    break;
                }
                if (inputValues.first._meta_PARAMTYPE == INT) {
                    faderInputs.first->setValue(inputValues.first.intValue);
                } else
                    faderInputs.first->setValue(inputValues.first.floatValue);
                break;
            }
            case ENCODER: {
                if (encoderInputs.first == nullptr) {
                    jassertfalse; // No encoder initalised
                    break;
                }
                if (inputValues.first._meta_PARAMTYPE == INT) {
                    encoderInputs.first->setValue(inputValues.first.intValue);
                } else
                    encoderInputs.first->setValue(inputValues.first.floatValue);
                break;
            }
            case DROPDOWN: {
                if (ddInputs.first == nullptr) {
                    jassertfalse; // No dropdown initalised
                    break;
                }
                if (inputValues.first._meta_PARAMTYPE != INT) {
                    jassertfalse; // Only int supported for dropdown
                } else
                    ddInputs.first->setSelectedItemIndex(inputValues.first.intValue);
                break;
            }
            case TEXTBOX: {
                if (textInputs.first == nullptr) {
                    jassertfalse; // No textbox initalised
                    break;
                }
                if (inputValues.first._meta_PARAMTYPE == INT) {
                    textInputs.first->setText(String(inputValues.first.intValue));
                } else if (inputValues.first._meta_PARAMTYPE == _GENERIC_FLOAT) {
                    textInputs.first->setText(String(inputValues.first.floatValue));
                } else
                    textInputs.first->setText(String(inputValues.first.stringValue));
                break;
            }
            case BUTTON_ARRAY:
                jassertfalse; // Not implemented
                break;
            case NONE:
                break;
        }
    }
    if (updateSecond) {
        switch (secondInputMethod) {
            case FADER: {
                if (faderInputs.second == nullptr) {
                    jassertfalse; // No fader initialised
                    break;
                }
                if (inputValues.second._meta_PARAMTYPE == INT) {
                    faderInputs.second->setValue(inputValues.second.intValue);
                } else
                    faderInputs.second->setValue(inputValues.second.floatValue);
                break;
            }
            case ENCODER: {
                if (encoderInputs.second == nullptr) {
                    jassertfalse; // No encoder initialised
                    break;
                }
                if (inputValues.second._meta_PARAMTYPE == INT) {
                    encoderInputs.second->setValue(inputValues.second.intValue);
                } else
                    encoderInputs.second->setValue(inputValues.second.floatValue);
                break;
            }
            case DROPDOWN: {
                if (ddInputs.second == nullptr) {
                    jassertfalse; // No dropdown initialised
                    break;
                }
                if (inputValues.second._meta_PARAMTYPE != INT) {
                    jassertfalse; // Only int supported for dropdown
                } else
                    ddInputs.second->setSelectedItemIndex(inputValues.second.intValue);
                break;
            }
            case TEXTBOX: {
                if (textInputs.second == nullptr) {
                    jassertfalse; // No textbox initialised
                    break;
                }
                if (inputValues.second._meta_PARAMTYPE == INT) {
                    textInputs.second->setText(String(inputValues.second.intValue));
                } else if (inputValues.second._meta_PARAMTYPE == _GENERIC_FLOAT) {
                    textInputs.second->setText(String(inputValues.second.floatValue));
                } else
                    textInputs.second->setText(String(inputValues.second.stringValue));
                break;
            }
            case BUTTON_ARRAY:
                jassertfalse; // Not implemented
                break;
            case NONE:
                break;
        }
    }
}

void OSCActionConstructor::MainComp::uponFadeCommandEnabledOrDisabled() {
    if (enableFadeCommandBtn.getToggleState()) {
        fadeTimeInput.setEnabled(true);
        // By default, we'll assume the second input method will be the same as the first.
        secondInputMethod = firstInputMethod;
        secondInputMethodDd.setEnabled(true);
        secondInputMethodDd.setVisible(true);
        // Get the index of input method
        auto tempInpMtdForPT = ALLOWED_INPUT_METHODS_FOR_TYPE.at(currentParamType);
        auto it = std::find(tempInpMtdForPT.begin(), tempInpMtdForPT.end(), secondInputMethod);
        size_t index;
        if (it == tempInpMtdForPT.end()) {
            jassertfalse; // We have issues.
            index = 0;
        } else {
            index = std::distance(tempInpMtdForPT.begin(), it);
        }

        // Set the second input method dropdown to match
        secondInputMethodDd.setSelectedItemIndex(index); // Or .setSelectedItemId(index + 1)

        uponNewInputMethodSelected(false, true);
        repaint();
        return;
    }

    // Otherwise:
    // We'll need to reset the second input method.
    switch (secondInputMethod) {
        case FADER:
            faderInputs.second.reset();
            break;
        case ENCODER:
            encoderInputs.second.reset();
            break;
        case DROPDOWN:
            ddInputs.second.reset();
            break;
        case TEXTBOX:
            textInputs.second.reset();
            break;
        case BUTTON_ARRAY:
            btnArrInputs.second.reset();
            break;
        case NONE:
            break;
    }
    secondInputMethod = NONE;
    secondInputMethodDd.setEnabled(false);
    secondInputMethodDd.setVisible(false);
    fadeTimeInput.setEnabled(false);
    repaint();
}

void OSCActionConstructor::MainComp::faderValueChanged(Fader *fdr) {
    // When a fader, the value must always be NonIter.
    float fdrVal = fdr->getValue();
    if (currentTemplateCopy == nullptr) {
        jassertfalse; // so. my question is. HOW DID YOU EVEN REACH HERE WITHOUT BEFORE SETTING THE CURRENT TEMPLATE? HOW????
        return;
    }
    if (!currentTemplateCopy->NONITER.valueIsValid(fdrVal)) {
        jassertfalse; // Invalid value. This should not happen as the fader should automatically set min/maxes.
        return;
    }
    if (fdr == faderInputs.first.get())
        inputValues.first.changeStore(fdrVal);
    else // Assume second fader
        inputValues.second.changeStore(fdrVal);
}

void OSCActionConstructor::MainComp::encoderValueChanged(Encoder *encdr) {
    // When an encoder, we need to check if it's an EnumParam or NonIter
    if (currentTemplateCopy == nullptr) {
        jassertfalse; // i... i really don't get paid enough for this. (I don't get paid at all actually)
        return;
    }
    if (!currentTemplateCopy->_META_UsesNonIter) {
        // EnumParam
        int encdrVal = std::round(encdr->getValue());
        if (encdrVal < 0 || encdrVal >= currentTemplateCopy->ENUMPARAM.len) {
            jassertfalse; // Invalid value. This should not happen as the encoder should automatically set min/maxes
        }
        if (encdr == encoderInputs.first.get())
            inputValues.first.changeStore(encdrVal);
        else
            inputValues.second.changeStore(encdrVal);
    } else {
        // Encoder does technically support INT, even though ALLOWED_INPUT_METHODS_FOR_TYPE doesn't by default
        // allow the ENCODER input method for ParamType INT. We should still account for it.
        if (currentParamType == INT) {
            const int encdrVal = std::round(encdr->getValue());
            if (!currentTemplateCopy->NONITER.valueIsValid(encdrVal)) {
                jassertfalse; // BUT THE ENCODER SETS THE LIMITS UPON INITIALISATION SO HOW DO YOU GET HERE
                return;
            }
            if (encdr == encoderInputs.first.get())
                inputValues.first.changeStore(encdrVal);
            else
                inputValues.second.changeStore(encdrVal);


        } else {
            const float encdrVal = encdr->getValue();
            if (!currentTemplateCopy->NONITER.valueIsValid(encdrVal)) {
                jassertfalse; // BUT THE ENCODER SETS THE LIMITS UPON INITIALISATION SO HOW DO YOU GET HERE
                return;
            }
            if (encdr == encoderInputs.first.get())
                inputValues.first.changeStore(encdrVal);
            else
                inputValues.second.changeStore(encdrVal);
        }
    }
}


void OSCActionConstructor::MainComp::buttonClicked(Button *btn) {
    if (btn == &enableFadeCommandBtn) {
        // If the button was somehow selected even though not permitted
        // ReSharper disable once CppDFAConstantConditions
        if (!fadeCommandEnabled) {
            enableFadeCommandBtn.setToggleState(false, dontSendNotification);
            jassertfalse; // Fade command attempted to enable even though not supported by current template
            return;
        }
        uponFadeCommandEnabledOrDisabled();
        return;
    }
    if (btn == &okBtn) {
        if (!currentActionIsValid()) {
            AlertWindow::showMessageBoxAsync(AlertWindow::WarningIcon, "Invalid Inputs",
                "Cannot construct action as some values are still invalid.", "Ok", this);
            return;
        }
        gracefulExit = true;
        exitModalState();
        getParentComponent()->userTriedToCloseWindow();
        return;
    }
    if (btn == &cancelBtn) {
        exitModalState();
        getParentComponent()->userTriedToCloseWindow();
        return;
    }
    jassertfalse; // Invalid button
}

void OSCActionConstructor::MainComp::wrappedTextEditorTextChanged(TextEditorWrapper* textEditor) {
    if (currentTemplateCopy == nullptr) {
        jassertfalse; // ??????????????????????????????????????????? HOW
        return;
    }
    if (!currentTemplateCopy->_META_UsesNonIter) {
        jassertfalse; // TextEditor not supported for EnumParam.
        return;
    }
    bool firstInput = textEditor == textInputs.first.get();
    String edtrVal = textEditor->getText();
    switch (currentParamType) {
        case LINF: case LOGF: case LEVEL_1024: case LEVEL_161: {
            edtrVal = edtrVal.trim();
            if (edtrVal.isEmpty() || // Empty, or
                !edtrVal.containsOnly("0123456789.-") || // Contains unallowed chars
                edtrVal.substring(1).contains("-") || // More than one negative symbol
                edtrVal.indexOf(".") != edtrVal.lastIndexOf(".")) { // More than one dot
                setTextEditorErrorState(textEditor, true);
                break;
            }

            const float val = edtrVal.getDoubleValue();
            if (!currentTemplateCopy->NONITER.valueIsValid(val)) {
                setTextEditorErrorState(textEditor, true);
                break;
            }

            if (firstInput)
                inputValues.first.changeStore(val);
            else
                inputValues.second.changeStore(val);
            setTextEditorErrorState(textEditor, false);
            break;
        }

        case STRING: {
            if (edtrVal.length() < currentTemplateCopy->NONITER.intMin || edtrVal.length() > currentTemplateCopy->NONITER.intMax) {
                // Invalid value
                setTextEditorErrorState(textEditor, true);
                break;
            }
            if (firstInput)
                inputValues.first.changeStore(edtrVal.toStdString());
            else
                inputValues.second.changeStore(edtrVal.toStdString());
            setTextEditorErrorState(textEditor, false);
            break;
        }
        case INT: {
            edtrVal = edtrVal.trim();
            if (edtrVal.isEmpty() || !edtrVal.containsOnly("0123456789-") || edtrVal.substring(1).contains("-")) {
                setTextEditorErrorState(textEditor, true);
                break;
            }

            const int val = edtrVal.getIntValue();
            if (edtrVal.getLargeIntValue() > NumericLimits::INTMAX) {
                setTextEditorErrorState(textEditor, true);
                break; // This value is too large and has overflown.
            }
            if (!currentTemplateCopy->NONITER.valueIsValid(val)) {
                setTextEditorErrorState(textEditor, true);
                break;
            }

            if (firstInput)
                inputValues.first.changeStore(val);
            else
                inputValues.second.changeStore(val);
            setTextEditorErrorState(textEditor, false);
            break;
        }
        default:
            jassertfalse; // Invalid ParamType for TextEditor.
            break;

    }

}

void OSCActionConstructor::MainComp::dropDownChanged(DropdownWrapper *dropDownThatHasChanged) {
    // When a dropdown, it can only be EnumParam
    if (currentTemplateCopy == nullptr) {
        jassertfalse; // :)
        return;
    }
    if (currentTemplateCopy->_META_UsesNonIter) {
        jassertfalse; // NonIter not supported for dropdown
        return;
    }

    // EnumParam
    int ddVal = dropDownThatHasChanged->getSelectedItemIndex();
    if (ddVal >= currentTemplateCopy->ENUMPARAM.len || currentTemplateCopy->ENUMPARAM.len == 0) {
        jassertfalse; // Invalid value. The Dropdown has elements out of index, or no elements.
        return;
    }
    if (dropDownThatHasChanged == ddInputs.first.get())
        inputValues.first.changeStore(ddVal);
    else
        inputValues.second.changeStore(ddVal);
}


void OSCActionConstructor::MainComp::setTextEditorErrorState(TextEditorWrapper *textEditor, bool error) {
    textEditor->setColour(TextEditorWrapper::ColourIds::outlineColourId,
               error ? UICfg::NEGATIVE_BUTTON_COLOUR : UICfg::POSITIVE_BUTTON_COLOUR);
    textEditor->setColour(TextEditorWrapper::ColourIds::focusedOutlineColourId,
           error ? UICfg::NEGATIVE_BUTTON_COLOUR : UICfg::TEXT_COLOUR);

}


void OSCActionConstructor::MainComp::labelTextChanged(Label *labelThatHasChanged) {
    if (labelThatHasChanged == &fadeTimeInput) {
        String txt = fadeTimeInput.getText();
        if (txt.isEmpty() ||
            !txt.containsOnly("0123456789.") ||
            txt.indexOf(".") != txt.lastIndexOf(".") ||
            txt.getDoubleValue() == 0.0) { // More than one dot
            setPathLabelErrorState(&fadeTimeInput, true);
            return;
        }
        lastValidFadeTime = txt.getDoubleValue();
        setPathLabelErrorState(&fadeTimeInput, false);
        return;
    }

    size_t pathLabelInputsSize = pathLabelInputs.size();

    if (pathLabelInputsSize != pathLabelInputValues.size() ||
        pathLabelInputsSize != pathLabelInputTemplates.size() ||
        pathLabelInputsSize != pathLabelFormattedValues.size()) {
        jassertfalse; // Uh oh... someone forgot to make sure the 3 vectors were properly updated...
        return;
    }
    for (size_t i = 0; i < pathLabelInputsSize; i++) {
        // Check pointer validity
        auto &lblUniquePtr = pathLabelInputs.at(i);
        if (lblUniquePtr == nullptr) {
            jassertfalse; // ... I... I.. BUT HOW???
            continue;
        }

        // Get pointer, check if correct label, get text value, then send off to be validated.
        auto lbl = lblUniquePtr.get();
        if (labelThatHasChanged != lbl) {
            continue;
        }
        auto txt = labelThatHasChanged->getText();
        pathLabelInputValues.at(i) = txt;

        // Let's first figure out what we need to convert the text to
        bool labelErrorState = true; // This is to track if any part of the label parsing process resulted in an
        // invalid value.

        const NonIter &argTemplate = pathLabelInputTemplates.at(i);
        switch (argTemplate._meta_PARAMTYPE) {
            case INT: {
                if (txt.isEmpty()) {
                    break; // Not worth continuing to process.
                }
                if (!txt.containsOnly("0123456789")) {
                    // Handle error here!
                    break;
                }
                int intVal = txt.getIntValue();
                if (!argTemplate.valueIsValid(intVal)) {
                    break;
                }
                pathLabelFormattedValues.at(i).changeStore(intVal);
                labelErrorState = false;
                break;
            }
            case STRING: {
                if (!argTemplate.valueIsValid(txt.toStdString())) {
                    break;
                }
                pathLabelFormattedValues.at(i).changeStore(txt.toStdString());
                labelErrorState = false;
                break;
            }
            default:
                jassertfalse; // Invalid ParamType for in-path argument template
        }

        setPathLabelErrorState(lbl, labelErrorState);
    }
}


void OSCActionConstructor::MainComp::setPathLabelErrorState(Label *lbl, bool error) {
    lbl->setColour(Label::ColourIds::outlineColourId,
                   error ? UICfg::NEGATIVE_BUTTON_COLOUR : UICfg::POSITIVE_BUTTON_COLOUR);
    lbl->setColour(Label::ColourIds::textColourId,
                   error ? UICfg::NEGATIVE_BUTTON_COLOUR : UICfg::TEXT_ACCENTED_COLOUR);
}


void OSCActionConstructor::MainComp::clearCurrentInputMethod(bool first, bool second) {
    if (first) {
        switch (firstInputMethod) {
            case FADER:
                faderInputs.first.reset();
                break;
            case ENCODER:
                encoderInputs.first.reset();
                break;
            case DROPDOWN:
                ddInputs.first.reset();
                break;
            case TEXTBOX:
                textInputs.first.reset();
                break;
            case BUTTON_ARRAY:
                btnArrInputs.first.reset();
                break;
            case NONE:
                jassertfalse; // Cannot reset a NONE input method
                break;
        }
    }
    if (second) {
        switch (secondInputMethod) {
            case FADER:
                faderInputs.second.reset();
                break;
            case ENCODER:
                encoderInputs.second.reset();
                break;
            case DROPDOWN:
                ddInputs.second.reset();
                break;
            case TEXTBOX:
                textInputs.second.reset();
                break;
            case BUTTON_ARRAY:
                btnArrInputs.second.reset();
                break;
            case NONE:
                jassertfalse; // Cannot reset a NONE input method
                break;
        }
    }
}

bool OSCActionConstructor::MainComp::currentActionIsValid() const {
    if (currentTemplateCopy == nullptr ||
        inputValues.first._meta_PARAMTYPE == _BLANK) {
        return false;
    }
    // First check fade time
    if (fadeCommandEnabled && enableFadeCommandBtn.getToggleState() && lastValidFadeTime <= 0.f)
        return false;


    // Then check path.
    bool canUsePathFromEditThisAction = pathFromEditThisAction.isNotEmpty();
    if (canUsePathFromEditThisAction) {
        // Test to check the path is valid.
        try {
            OSCAddressPattern _ {pathFromEditThisAction};
        }
        catch (OSCFormatError) { canUsePathFromEditThisAction = false; }
    }

    size_t pathLabelInputsSize = pathLabelInputs.size();

    if (pathLabelInputsSize == pathLabelInputValues.size() &&
        pathLabelInputsSize == pathLabelInputTemplates.size() &&
        pathLabelInputsSize == pathLabelFormattedValues.size()) {
        bool lastWasInvalid { false };
        for (size_t i = 0; i < pathLabelInputsSize; i++) {
            // Only need to check ValueStorers.
            const NonIter& argTemplate = pathLabelInputTemplates.at(i);
            switch (argTemplate._meta_PARAMTYPE) {
                case INT: {
                    if (!argTemplate.valueIsValid(pathLabelFormattedValues.at(i).intValue))
                        lastWasInvalid = true;
                    break;
                }
                case STRING: {
                    if (!argTemplate.valueIsValid(pathLabelFormattedValues.at(i).stringValue))
                        lastWasInvalid = true;
                    break;
                }
                default:
                    jassertfalse; // Invalid option for in-path argument
                    lastWasInvalid = false;
                    break;
            }
            if (lastWasInvalid) {
                if (!canUsePathFromEditThisAction) {
                    return false;
                }
                // Ok this forces us to use the path from edit this action since it's the only valid one.
                usePathFromEditThisAction = true;
                break;
            }
        }
    } else {
        jassertfalse; // Sizes of path input vectors do not match
        if (!canUsePathFromEditThisAction)
            return false;
        // Forced to use pathFromEditThisAction
        usePathFromEditThisAction = true;
    }

    // Now, check values.
    // Check inputValues.first
    if (!currentTemplateCopy->_META_UsesNonIter) {
        if (inputValues.first._meta_PARAMTYPE != INT)
            return false;
        if (currentTemplateCopy->ENUMPARAM.len == 0 || inputValues.first.intValue < 0 ||
            inputValues.first.intValue >= currentTemplateCopy->ENUMPARAM.len)
            return false;
    } else {
        const NonIter& ni = currentTemplateCopy->NONITER;
        switch (ni._meta_PARAMTYPE) {
            case INT: case BITSET: {
                if (inputValues.first._meta_PARAMTYPE != INT || !ni.valueIsValid(inputValues.first.intValue))
                    return false;
                break;
            }
            case LINF: case LOGF: case LEVEL_1024: case LEVEL_161: {
                if (inputValues.first._meta_PARAMTYPE != _GENERIC_FLOAT || !ni.valueIsValid(inputValues.first.floatValue))
                    return false;
                break;
            }
            case STRING:
                if (inputValues.first._meta_PARAMTYPE != STRING || !ni.valueIsValid(inputValues.first.stringValue))
                    return false;
                break;
            default:
                jassertfalse; // Unsupported ParamType for Templated NonIter
                return false;
        }
    }

    // Now check second - if applicable
    if (enableFadeCommandBtn.getToggleState()) {
        if (!fadeCommandEnabled) {
            jassertfalse; // Cannot fade command a template that doesn't support fading
            return false;
        }
        if (!currentTemplateCopy->_META_UsesNonIter) {
            if (inputValues.second._meta_PARAMTYPE != INT)
                return false;
            if (currentTemplateCopy->ENUMPARAM.len == 0 || inputValues.second.intValue < 0 ||
                inputValues.second.intValue >= currentTemplateCopy->ENUMPARAM.len)
                return false;
        } else {
            const NonIter& ni = currentTemplateCopy->NONITER;
            switch (ni._meta_PARAMTYPE) {
                case INT: case BITSET: {
                    if (inputValues.second._meta_PARAMTYPE != INT || !ni.valueIsValid(inputValues.second.intValue))
                        return false;
                    break;
                }
                case LINF: case LOGF: case LEVEL_1024: case LEVEL_161: {
                    if (inputValues.second._meta_PARAMTYPE != _GENERIC_FLOAT || !ni.valueIsValid(inputValues.second.floatValue))
                        return false;
                    break;
                }
                case STRING:
                    if (inputValues.second._meta_PARAMTYPE != STRING || !ni.valueIsValid(inputValues.second.stringValue))
                        return false;
                    break;
                default:
                    jassertfalse; // Unsupported ParamType for Templated NonIter
                    return false;
            }
        }
    }

    // OK... we should be fine. Let's return true.
    return true;
}

CueOSCAction OSCActionConstructor::MainComp::getCueOSCAction() const {
    if (currentTemplateCopy == nullptr) {
        jassertfalse; // Bad copy
        return CueOSCAction(false);
    }
    // Determine what to use for path
    String path;
    if (usePathFromEditThisAction) {
        path = pathFromEditThisAction;
    } else {
        path = OSCDeviceSender::fillInArgumentsOfEmbeddedPath(currentTemplateCopy->PATH,  pathLabelFormattedValues);
    }
    if (enableFadeCommandBtn.getToggleState()) {
        return CueOSCAction(
            path, lastValidFadeTime, currentTemplateCopy->NONITER, inputValues.first, inputValues.second, currentTemplateCopy->ID);
    }
    // Non-fading
    if (currentTemplateCopy->_META_UsesNonIter) {
        return CueOSCAction(path, {currentTemplateCopy->NONITER}, {inputValues.first}, currentTemplateCopy->ID);
    }
    return CueOSCAction(path, {currentTemplateCopy->ENUMPARAM}, {inputValues.first}, currentTemplateCopy->ID);
}


// ==============================================================================


void Encoder::resized() {
    // The encoder rotary can handle its own bounds
    encoder.setBounds(getLocalBounds());

    // We still have to manually set the bounds for the manual input box.
    auto bounds = getLocalBounds().removeFromTop(0.9 * getHeight());
    bounds.removeFromLeft(0.05 * bounds.getWidth());
    bounds.removeFromRight(0.05 * bounds.getWidth());

    auto inputBoxBounds = Rectangle<int>(bounds.getCentreX() - getWidth() * 0.25,
                                         bounds.getCentreY() - getHeight() * 0.0625,
                                         getWidth() * 0.5, getHeight() * 0.125);
    manualInputBox.setBounds(inputBoxBounds);
    manualInputBox.setFont(inputBoxFont.withHeight(inputBoxBounds.getHeight() * 0.7f));
}


void Fader::resized() {
    auto boundsWidth = getWidth();
    faderHeight = boundsWidth * UICfg::FADER_KNOB_WIDTH_AS_PROPORTION_TO_BOUNDS_WIDTH *
                  UICfg::FADER_KNOB_HEIGHT_AS_PROPORTION_TO_WIDTH;

    auto boundsHeight = getHeight();
    boundsHeight -= faderHeight;
    boundsHeightWithoutFaderOverflow = boundsHeight;


    bgImage = Image(Image::ARGB, boundsWidth, boundsHeight, true);
    slider->setBounds(Rectangle<int>(0, faderHeight / 2, getWidth(), getHeight() - faderHeight));
    Graphics g(bgImage);

    // Centerline
    Rectangle<int> centerBarRect = getLocalBounds();
    int sidePadding = static_cast<int>(std::ceil(boundsWidth * UICfg::FADER_CENTERLINE_SIDE_PADDING));
    centerBarRect.removeFromLeft(sidePadding);
    centerBarRect.removeFromRight(sidePadding);
    g.setColour(UICfg::CENTERLINE_COLOUR);
    g.fillRect(centerBarRect);


    // Fader knob size is soley dependent on width.
    faderKnobImage = Image(Image::ARGB, boundsWidth * UICfg::FADER_KNOB_WIDTH_AS_PROPORTION_TO_BOUNDS_WIDTH,
                           faderHeight, true);
    // Half of the fader knob width left of the centerline
    faderTopLeftX = std::ceil(
        boundsWidth / 2 - boundsWidth * UICfg::FADER_KNOB_WIDTH_AS_PROPORTION_TO_BOUNDS_WIDTH / 2);

    auto faderLineHeight = faderKnobImage.getHeight() * UICfg::FADER_KNOB_LINE_HEIGHT_AS_PROPORTION_TO_HEIGHT;

    Graphics gFdr(faderKnobImage);
    gFdr.setColour(UICfg::STRONG_BORDER_COLOUR);
    gFdr.fillRect(getLocalBounds());
    gFdr.setColour(UICfg::BG_SECONDARY_COLOUR);

    gFdr.fillRect(Rectangle<int>(0, (faderHeight - faderLineHeight) / 2, faderKnobImage.getWidth(), faderLineHeight));


    if (paramType != LEVEL_1024 && paramType != LEVEL_161) {
        return; // Don't need do anything more. Everything only applies to when a level argument is in use.
    }

    // Let's also set our value label font height
    monospaceFontWithFontSize.setHeight(boundsHeight * UICfg::FADER_VALUE_TEXT_FONT_HEIGHT);

    // Level markers
    int lineThickness = std::ceil(boundsHeight * UICfg::LEVEL_MARKER_THICKNESS);
    int lineSidePadding = std::ceil(boundsWidth * 0.35f);
    int labelToMarkerPadding = std::ceil(lineSidePadding * UICfg::STD_PADDING);
    // Padding between the marker line and the text labelling the line

    float textHeight = boundsHeight * UICfg::FADER_MARKER_LABEL_FONT_HEIGHT;
    g.setFont(levelLabelFont);
    g.setFont(textHeight);

    for (const auto &[lbl, heightPerc]: LEVEL_MARKERS) {
        if (heightPerc > 1.f || heightPerc < 0.f) {
            jassertfalse; // Right... and no one sees a problem with this right?
        }
        int centerHeight = std::ceil(heightPerc * boundsHeight);
        int initialY;
        // The code below ensures the initial Y-coord does not go outside the bounds.
        if (centerHeight == 0) {
            // At top height
            initialY = 0;
        } else if (centerHeight == boundsHeight) {
            // At bottom height
            initialY = boundsHeight - lineThickness;
        } else {
            initialY = centerHeight - lineThickness;
        }
        // We need to leave some space on left & right for label markers (e.g., -90, -60, ..., +10)
        Rectangle<int> line = {lineSidePadding, initialY, boundsWidth - lineSidePadding * 2, lineThickness};
        g.drawRect(line);


        // Again, the code below ensures the initial Y-coord does not go outside the bounds.
        if (centerHeight == 0) {
            // At top height
            initialY = 0;
        } else if (centerHeight == boundsHeight) {
            // At bottom height
            initialY = boundsHeight - static_cast<int>(std::floor(textHeight));
        } else {
            initialY = static_cast<int>(std::floor(centerHeight - textHeight / 2));
        }

        // We also need the level label
        Rectangle<int> labelTextBox = {
            boundsWidth - lineSidePadding + labelToMarkerPadding,
            initialY, lineSidePadding - labelToMarkerPadding, static_cast<int>(std::floor(textHeight))
        };

        // Format text appropriately
        g.drawText(lbl, labelTextBox, Justification::centredLeft);
    }
}

void Fader::paint(Graphics &g) {
    g.drawImage(bgImage, Rectangle<float>(0, faderHeight / 2, getWidth(), getHeight() - faderHeight));
    g.drawImageAt(faderKnobImage, faderTopLeftX, (1.0 - slider->getValue()) * boundsHeightWithoutFaderOverflow);

    g.setColour(UICfg::TEXT_COLOUR);
    g.setFont(monospaceFontWithFontSize);

    // Heavily inspired by https://forum.juce.com/t/draw-rotated-text/14695/11. Thanks matkatmusic!
    // Unsure why the formatted string value doesn't draw when the value isn't a dB unit?
    GlyphArrangement ga;
    String strVal = getFormattedStringVal();
    ga.addLineOfText(monospaceFontWithFontSize, strVal, 0, 0);
    Path p;
    ga.createPath(p);

    auto centerX = static_cast<int>(std::ceil(getWidth() * UICfg::FADER_CENTERLINE_SIDE_PADDING)) / 2;
    auto centerY = getHeight() / 2;

    p.applyTransform(AffineTransform()
        .translated(
            centerX - GlyphArrangement::getStringWidth(monospaceFontWithFontSize, strVal) / 2,
            centerY)
        .rotated(-MathConstants<float>::halfPi,
                 centerX,
                 centerY
        )
    );
    g.fillPath(p);
}


Encoder::Encoder(
    Units unit, const double minDeg, const double minValue, const double maxDeg, const double maxValue,
    const double middlePV, const double defaultPV,
    const String &minLabel, const String &maxLabel,
    const int overrideRoundingToXDecimalPlaces, const ParamType paramType, const bool middleProvidedAsPercentage,
    const bool defaultProvidedAsPercentage): unit(unit),
                                             roundToNDigits((overrideRoundingToXDecimalPlaces == -1)
                                                                ? ROUND_TO_NUM_DECIMAL_PLACES_FOR_UNIT.at(unit)
                                                                : overrideRoundingToXDecimalPlaces),
                                             paramType(paramType),
                                             minValue(minValue), minPos(degreesToRadians(minDeg)), minLabel(minLabel),
                                             maxValue(maxValue), maxPos(degreesToRadians(maxDeg)), maxLabel(maxLabel),
                                             encoder(unit, minDeg, minValue, maxDeg, maxValue,
                                                     middlePV, defaultPV, minLabel, maxLabel,
                                                     overrideRoundingToXDecimalPlaces, paramType,
                                                     middleProvidedAsPercentage, defaultProvidedAsPercentage),
                                             _isOptionParam(false),
                                             _isEnumParam(false), _option(nullOption), _enumParam(nullEnum) {
    if (minValue >= maxValue) {
        jassertfalse; // Min value must be less than max value
        return;
    }
    init();
}

// // EncoderRotary doesn't have an initaliser for NonIter objects, so we'll manually pass the values along.
// Encoder::Encoder(const NonIter &nonIter, double minDeg, double maxDeg, const String &minLabel,
//                  const String &maxLabel): unit(nonIter._meta_UNIT),
//                                           roundToNDigits(ROUND_TO_NUM_DECIMAL_PLACES_FOR_UNIT.at(unit)),
//                                           paramType(nonIter._meta_PARAMTYPE),
//                                           minValue(nonIter._meta_PARAMTYPE == INT ? nonIter.intMin : nonIter.floatMin),
//                                           minPos(degreesToRadians(minDeg)),
//                                           minLabel(minLabel),
//                                           maxValue(nonIter._meta_PARAMTYPE == INT ? nonIter.intMax : nonIter.floatMax),
//                                           maxPos(degreesToRadians(maxDeg)),
//                                           maxLabel(maxLabel),
//                                           encoder(unit, minDeg, minValue, maxDeg, maxValue,
//                                                   0.5, (nonIter._meta_PARAMTYPE == INT
//                                                             ? nonIter.defaultIntValue
//                                                             : nonIter.defaultFloatValue), minLabel, maxLabel,
//                                                   -1, paramType,
//                                                   true, false),
//                                           _isOptionParam(false),
//                                           _isEnumParam(false),
//                                           _option(nullOption), _enumParam(nullEnum) {
//     if (!ALLOWED_PARAMTYPES.count(nonIter._meta_PARAMTYPE)) {
//         jassertfalse; // Unallowed ParamType for Encoder. Expect undefined behaviour.
//     }
//     init();
// }


Encoder::Encoder(const OptionParam &option, const double minDeg, const double maxDeg, const int defaultIndex,
                 const String &minLabel, const String &maxLabel): unit(NONE),
                                                                  roundToNDigits(-1),
                                                                  paramType(LINF),
                                                                  minValue(0), minPos(degreesToRadians(minDeg)),
                                                                  minLabel(minLabel),
                                                                  maxValue(option.len - 1),
                                                                  maxPos(degreesToRadians(maxDeg)),
                                                                  maxLabel(maxLabel),
                                                                  encoder(option, minDeg, maxDeg, defaultIndex,
                                                                          minLabel,
                                                                          maxLabel),
                                                                  _isOptionParam(true),
                                                                  _isEnumParam(false),
                                                                  _option(option), _enumParam(nullEnum) {
    init();
}

Encoder::Encoder(const EnumParam &enumParam, const double minDeg, const double maxDeg, const int defaultIndex,
                 const String &minLabel, const String &maxLabel): unit(NONE),
                                                                  roundToNDigits(-1),
                                                                  paramType(LINF),
                                                                  minValue(0), minPos(degreesToRadians(minDeg)),
                                                                  minLabel(minLabel),
                                                                  maxValue(enumParam.len - 1),
                                                                  maxPos(degreesToRadians(maxDeg)),
                                                                  maxLabel(maxLabel),
                                                                  encoder(enumParam, minDeg, maxDeg, defaultIndex,
                                                                          minLabel,
                                                                          maxLabel),
                                                                  _isOptionParam(false),
                                                                  _isEnumParam(true),
                                                                  _option(nullOption), _enumParam(enumParam) {
    init();
}


// TODO: Remove redundant isOption/EnumParam, and option and enumParam members
EncoderRotary::EncoderRotary(
    Units unit,
    const double minDeg, const double minValue,
    const double maxDeg, const double maxValue,
    const double middlePV, const double defaultPV,
    const String &minLabel, const String &maxLabel,
    const int overrideRoundingToXDecimalPlaces, const ParamType paramType, const bool middleProvidedAsPercentage,
    const bool defaultProvidedAsPercentage): paramType(paramType),
                                             minValue(minValue), minPos(degreesToRadians(minDeg)), minLabel(minLabel),
                                             maxValue(maxValue), maxPos(degreesToRadians(maxDeg)), maxLabel(maxLabel),
                                             isOptionParam(false), isEnumParam(false),
                                             Slider(RotaryHorizontalVerticalDrag, NoTextBox),
                                             option(nullOption), enumParam(nullEnum) {
    if (minValue >= maxValue) {
        jassertfalse; // Min value must be less than max value
        return;
    }
    if (middleProvidedAsPercentage) {
        middleValue = inferValueFromMinMaxAndPercentage(minValue, maxValue, middlePV, paramType);
        middlePos = degreesToRadians(minDeg + (maxDeg - minDeg) * middlePV);
    } else {
        middleValue = middlePV;
        // Normalise middlePV to the range of minValue and maxValue
        middlePos = degreesToRadians(
            minDeg + (maxDeg - minDeg) * inferPercentageFromMinMaxAndValue(
                minValue, maxValue, middlePV, paramType));
    }
    if (defaultProvidedAsPercentage) {
        defaultValue = inferValueFromMinMaxAndPercentage(minValue, maxValue, defaultPV, paramType);
        defaultPos = degreesToRadians(minDeg + (maxDeg - minDeg) * defaultPV);
    } else {
        defaultValue = defaultPV;
        defaultPos = degreesToRadians(
            minDeg + (maxDeg - minDeg) *
            inferPercentageFromMinMaxAndValue(minValue, maxValue, defaultPV, paramType));
    }
    setDoubleClickReturnValue(true, defaultValue);
    setValue(defaultValue);


    int roundTo = (overrideRoundingToXDecimalPlaces == -1)
                      ? ROUND_TO_NUM_DECIMAL_PLACES_FOR_UNIT.at(unit)
                      : overrideRoundingToXDecimalPlaces;

    switch (paramType) {
        case LINF:
            setRange(minValue, maxValue, std::pow(10.0, -roundTo));
            break;
        case LOGF:
            setNormalisableRange(getNormalisableRangeExp(minValue, maxValue));
            break;
        case LEVEL_161:
            setNormalisableRange(LEVEL_161_NORMALISABLE_RANGE);
            break;
        case LEVEL_1024:
            setNormalisableRange(LEVEL_1024_NORMALISABLE_RANGE);
            break;
        case INT:
            setRange(0, maxValue, 1);
        default:
            jassertfalse;
    }
}


EncoderRotary::EncoderRotary(const OptionParam &option, const double minDeg, const double maxDeg,
                             const int defaultIndex,
                             const String &minLabel, const String &maxLabel): isOptionParam(true), isEnumParam(false),
                                                                              option(option),
                                                                              paramType(LINF),
                                                                              minValue(0),
                                                                              minPos(degreesToRadians(minDeg)),
                                                                              minLabel(minLabel),
                                                                              maxValue(option.len - 1),
                                                                              maxPos(degreesToRadians(maxDeg)),
                                                                              maxLabel(maxLabel),
                                                                              Slider(
                                                                                  SliderStyle::RotaryHorizontalVerticalDrag,
                                                                                  Slider::NoTextBox),
                                                                              enumParam(nullEnum) {
    // Let's set the default value and position
    setDoubleClickReturnValue(true, defaultIndex);
    setValue(defaultIndex);
    setRange(0, option.len - 1, 1); // Set the range from 0 to len - 1 with a step of 1
}


EncoderRotary::EncoderRotary(const EnumParam &enumParam, const double minDeg, const double maxDeg,
                             const int defaultIndex, const String &minLabel, const String &maxLabel)
    : isOptionParam(false), isEnumParam(true),
      enumParam(enumParam),
      paramType(LINF),
      minValue(0),
      minPos(degreesToRadians(minDeg)),
      minLabel(minLabel),
      maxValue(option.len - 1),
      maxPos(degreesToRadians(maxDeg)),
      maxLabel(maxLabel),
      Slider(RotaryHorizontalVerticalDrag,
             NoTextBox),
      option(nullOption) {
    // Let's set the default value and position
    setDoubleClickReturnValue(true, defaultIndex);
    setValue(defaultIndex);
    setRange(0, enumParam.len - 1, 1); // Set the range from 0 to len - 1 with a step of 1
}


void EncoderRotary::resized() {
    // Let's set up our encoder bounds.
    boundsCopy = getLocalBounds();
    boundsCopy.removeFromBottom(getLocalBounds().getHeight() * 0.1);
    // Labels will be drawn at the bottom 10% of the bounds.
    // Use getLocalBounds() as boundsCopy will have change after a removeFromLeft call, meaning the removeFromRight will
    // remove 5% of the remaining 95% width, not the original width.
    boundsCopy.removeFromLeft(getLocalBounds().getWidth() * 0.05);
    boundsCopy.removeFromRight(getLocalBounds().getWidth() * 0.05);
    encoderRadius = jmin(boundsCopy.getWidth(), boundsCopy.getHeight()) * 0.5f;
    auto center = boundsCopy.getCentre();

    textHeight = encoderRadius * UICfg::ROTARY_TEXT_HEIGHT;


    // Now draw label to image to prevent rerendering every paint call.
    predrawnLabels = Image(Image::ARGB, getWidth(), getHeight(), true);
    Graphics g(predrawnLabels);

    g.setFont(UICfg::DEFAULT_MONOSPACE_FONT);
    auto labelHeights = textHeight * 0.7f;
    g.setFont(labelHeights);
    g.setColour(UICfg::TEXT_COLOUR);

    // This is the Minimum Label
    Rectangle<float> textBound;
    textBound.setSize(GlyphArrangement::getStringWidthInt(g.getCurrentFont(), minLabel), labelHeights);
    textBound.setCentre(center.getPointOnCircumference(encoderRadius + labelHeights * 0.75f, minPos));
    textBound.setY(textBound.getY() + labelHeights);

    g.drawFittedText(minLabel, textBound.toNearestInt(), Justification::topLeft, 1);

    // This is the Maximum Label
    textBound.setSize(GlyphArrangement::getStringWidthInt(g.getCurrentFont(), maxLabel), labelHeights);
    textBound.setCentre(center.getPointOnCircumference(encoderRadius + labelHeights * 0.75f, maxPos));
    textBound.setY(textBound.getY() + labelHeights);

    g.drawFittedText(maxLabel, textBound.toNearestInt(), Justification::topRight, 1);
}


void EncoderRotary::paint(Graphics &g) {
    auto enabled = isEnabled();

    g.setColour(enabled ? UICfg::ROTARY_ENABLED_COLOUR : UICfg::ROTARY_DISABLED_COLOUR);
    g.fillEllipse(boundsCopy.toFloat());

    auto center = boundsCopy.getCentre();

    Path pointer;

    // We'll make a pointer rectangle.
    Rectangle<float> r;
    // Let's figure out the pointer width
    float ptrWdth = encoderRadius * UICfg::ROTARY_POINTER_WIDTH;
    r.setLeft(center.getX() - ptrWdth);
    r.setRight(center.getX() + ptrWdth);
    r.setTop(boundsCopy.getY());
    r.setBottom(center.getY() - textHeight * UICfg::ROTARY_TEXT_PADDING);

    pointer.addRoundedRectangle(r, ptrWdth);

    float sliderAngleAsRadian = jmap(getNormalisableRange().convertTo0to1(getValue()),
                                     minPos, maxPos);
    pointer.applyTransform(AffineTransform::rotation(sliderAngleAsRadian, center.getX(), center.getY()));

    g.setColour(UICfg::ROTARY_POINTER_COLOUR);
    g.fillPath(pointer);


    // Draw the pre-drawn labels
    g.drawImage(predrawnLabels, getLocalBounds().toFloat());
}
